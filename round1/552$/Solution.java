/*
    三维dp，用维度保存状态
    dp[n][i][j] 代表长度为n，含有i个A，最后有j个L的字符串个数
    使用滚动数组优化
*/

class Solution {
    public int checkRecord(int n) {
        if (n == 0)
            return 0;
        
        int[][][] dp = {{{0, 0, 0}, {0, 0, 0}}, {{1, 1, 0}, {1, 0, 0}}};
        for (int i = 2; i <= n; i++) {
            // A和L都为0，只能是插入P，这样之前有L的都变成没有了
            dp[i % 2][0][0] = (int) ((0L + dp[(i - 1) % 2][0][0] + dp[(i - 1) % 2][0][1] + dp[(i - 1) % 2][0][2]) % (1e9 + 7));
            // 结尾有一个L，只能来自于结尾没有L，插入一个L
            dp[i % 2][0][1] = dp[(i - 1) % 2][0][0];
            // 结尾有两个L，只能来自于结尾一个L，插入一个L
            dp[i % 2][0][2] = dp[(i - 1) % 2][0][1];
            // 1个A，没有结尾L，可以来自于原来有A插入P，或者直接插入A
            dp[i % 2][1][0] = (int) ((0L + dp[(i - 1) % 2][1][0] + dp[(i - 1) % 2][1][1] + dp[(i - 1) % 2][1][2] 
                + dp[(i - 1) % 2][0][0] + dp[(i - 1) % 2][0][1] + dp[(i - 1) % 2][0][2]) % (1e9 + 7));
            // 结尾有一个L，只能来自于结尾没有L，插入一个L
            dp[i % 2][1][1] = dp[(i - 1) % 2][1][0];
            // 结尾有两个L，只能来自于结尾一个L，插入一个L
            dp[i % 2][1][2] = dp[(i - 1) % 2][1][1];
        }
        
        return (int) ((0L + dp[n % 2][1][0] + dp[n % 2][1][1] + dp[n % 2][1][2] 
                + dp[n % 2][0][0] + dp[n % 2][0][1] + dp[n % 2][0][2]) % (1e9 + 7));
    }
}